# Lag transforms

### `Lag`

```python
Lag(lag)
```

Bases: <code>[\_BaseLagTransform](#coreforecast.lag_transforms._BaseLagTransform)</code>

Simple lag operator

**Parameters:**

Name | Type | Description | Default
---- | ---- | ----------- | -------
`lag` | <code>[int](#int)</code> | Number of periods to offset | *required*

#### `Lag.stack`

```python
stack(transforms)
```

#### `Lag.take`

```python
take(_idxs)
```

#### `Lag.transform`

```python
transform(ga)
```

#### `Lag.update`

```python
update(ga)
```

### `RollingMean`

Bases: <code>[\_RollingBase](#coreforecast.lag_transforms._RollingBase)</code>

#### `RollingMean.stack`

```python
stack(transforms)
```

#### `RollingMean.take`

```python
take(_idxs)
```

#### `RollingMean.transform`

```python
transform(ga)
```

#### `RollingMean.update`

```python
update(ga)
```

### `RollingStd`

Bases: <code>[\_RollingBase](#coreforecast.lag_transforms._RollingBase)</code>

#### `RollingStd.stack`

```python
stack(transforms)
```

#### `RollingStd.take`

```python
take(_idxs)
```

#### `RollingStd.transform`

```python
transform(ga)
```

#### `RollingStd.update`

```python
update(ga)
```

### `RollingMin`

Bases: <code>[\_RollingBase](#coreforecast.lag_transforms._RollingBase)</code>

#### `RollingMin.stack`

```python
stack(transforms)
```

#### `RollingMin.take`

```python
take(_idxs)
```

#### `RollingMin.transform`

```python
transform(ga)
```

#### `RollingMin.update`

```python
update(ga)
```

### `RollingMax`

Bases: <code>[\_RollingBase](#coreforecast.lag_transforms._RollingBase)</code>

#### `RollingMax.stack`

```python
stack(transforms)
```

#### `RollingMax.take`

```python
take(_idxs)
```

#### `RollingMax.transform`

```python
transform(ga)
```

#### `RollingMax.update`

```python
update(ga)
```

### `RollingQuantile`

```python
RollingQuantile(lag, p, window_size, min_samples=None)
```

Bases: <code>[\_RollingBase](#coreforecast.lag_transforms._RollingBase)</code>

Rolling quantile

**Parameters:**

Name | Type | Description | Default
---- | ---- | ----------- | -------
`lag` | <code>[int](#int)</code> | Number of periods to offset by before applying the transformation | *required*
`p` | <code>[float](#float)</code> | Quantile to compute | *required*
`window_size` | <code>[int](#int)</code> | Length of the rolling window | *required*
`min_samples` | <code>[int](#int)</code> | Minimum number of samples required to compute the statistic.
If None, defaults to window_size. | <code>None</code>

#### `RollingQuantile.stack`

```python
stack(transforms)
```

#### `RollingQuantile.take`

```python
take(_idxs)
```

#### `RollingQuantile.transform`

```python
transform(ga)
```

#### `RollingQuantile.update`

```python
update(ga)
```

### `SeasonalRollingMean`

Bases: <code>[\_SeasonalRollingBase](#coreforecast.lag_transforms._SeasonalRollingBase)</code>

#### `SeasonalRollingMean.stack`

```python
stack(transforms)
```

#### `SeasonalRollingMean.take`

```python
take(_idxs)
```

#### `SeasonalRollingMean.transform`

```python
transform(ga)
```

#### `SeasonalRollingMean.update`

```python
update(ga)
```

### `SeasonalRollingStd`

Bases: <code>[\_SeasonalRollingBase](#coreforecast.lag_transforms._SeasonalRollingBase)</code>

#### `SeasonalRollingStd.stack`

```python
stack(transforms)
```

#### `SeasonalRollingStd.take`

```python
take(_idxs)
```

#### `SeasonalRollingStd.transform`

```python
transform(ga)
```

#### `SeasonalRollingStd.update`

```python
update(ga)
```

### `SeasonalRollingMin`

Bases: <code>[\_SeasonalRollingBase](#coreforecast.lag_transforms._SeasonalRollingBase)</code>

#### `SeasonalRollingMin.stack`

```python
stack(transforms)
```

#### `SeasonalRollingMin.take`

```python
take(_idxs)
```

#### `SeasonalRollingMin.transform`

```python
transform(ga)
```

#### `SeasonalRollingMin.update`

```python
update(ga)
```

### `SeasonalRollingMax`

Bases: <code>[\_SeasonalRollingBase](#coreforecast.lag_transforms._SeasonalRollingBase)</code>

#### `SeasonalRollingMax.stack`

```python
stack(transforms)
```

#### `SeasonalRollingMax.take`

```python
take(_idxs)
```

#### `SeasonalRollingMax.transform`

```python
transform(ga)
```

#### `SeasonalRollingMax.update`

```python
update(ga)
```

### `SeasonalRollingQuantile`

```python
SeasonalRollingQuantile(lag, p, season_length, window_size, min_samples=None)
```

Bases: <code>[\_SeasonalRollingBase](#coreforecast.lag_transforms._SeasonalRollingBase)</code>

Seasonal rolling statistic

**Parameters:**

Name | Type | Description | Default
---- | ---- | ----------- | -------
`lag` | <code>[int](#int)</code> | Number of periods to offset by before applying the transformation | *required*
`p` | <code>[float](#float)</code> | Quantile to compute | *required*
`season_length` | <code>[int](#int)</code> | Length of the seasonal period, e.g. 7 for weekly data | *required*
`window_size` | <code>[int](#int)</code> | Length of the rolling window | *required*
`min_samples` | <code>[int](#int)</code> | Minimum number of samples required to compute the statistic.
If None, defaults to window_size. | <code>None</code>

#### `SeasonalRollingQuantile.stack`

```python
stack(transforms)
```

#### `SeasonalRollingQuantile.take`

```python
take(_idxs)
```

#### `SeasonalRollingQuantile.transform`

```python
transform(ga)
```

#### `SeasonalRollingQuantile.update`

```python
update(ga)
```
  
### `ExpandingMean`

Bases: <code>[\_ExpandingBase](#coreforecast.lag_transforms._ExpandingBase)</code>

#### `ExpandingMean.stack`

```python
stack(transforms)
```

#### `ExpandingMean.take`

```python
take(idxs)
```

#### `ExpandingMean.transform`

```python
transform(ga)
```

#### `ExpandingMean.update`

```python
update(ga)
```

### `ExpandingStd`

Bases: <code>[\_ExpandingBase](#coreforecast.lag_transforms._ExpandingBase)</code>

#### `ExpandingStd.stack`

```python
stack(transforms)
```

#### `ExpandingStd.take`

```python
take(idxs)
```

#### `ExpandingStd.transform`

```python
transform(ga)
```

#### `ExpandingStd.update`

```python
update(ga)
```

### `ExpandingMin`

Bases: <code>[\_ExpandingComp](#coreforecast.lag_transforms._ExpandingComp)</code>

#### `ExpandingMin.stack`

```python
stack(transforms)
```

#### `ExpandingMin.take`

```python
take(idxs)
```

#### `ExpandingMin.transform`

```python
transform(ga)
```

#### `ExpandingMin.update`

```python
update(ga)
```

### `ExpandingMax`

Bases: <code>[\_ExpandingComp](#coreforecast.lag_transforms._ExpandingComp)</code>

#### `ExpandingMax.stack`

```python
stack(transforms)
```

#### `ExpandingMax.take`

```python
take(idxs)
```

#### `ExpandingMax.transform`

```python
transform(ga)
```

#### `ExpandingMax.update`

```python
update(ga)
```

### `ExpandingQuantile`

```python
ExpandingQuantile(lag, p)
```

Bases: <code>[\_BaseLagTransform](#coreforecast.lag_transforms._BaseLagTransform)</code>

Expanding quantile

**Parameters:**

Name | Type | Description | Default
---- | ---- | ----------- | -------
`lag` | <code>[int](#int)</code> |
Number of periods to offset by before applying the transformation | *required*
`p` | <code>[float](#float)</code> |
Quantile to compute | *required*

#### `ExpandingQuantile.stack`

```python
stack(transforms)
```

#### `ExpandingQuantile.take`

```python
take(_idxs)
```

#### `ExpandingQuantile.transform`

```python
transform(ga)
```

#### `ExpandingQuantile.update`

```python
update(ga)
```

### `ExponentiallyWeightedMean`

```python
ExponentiallyWeightedMean(lag, alpha)
```

Bases: <code>[\_BaseLagTransform](#coreforecast.lag_transforms._BaseLagTransform)</code>

Exponentially weighted mean

**Parameters:**

Name | Type | Description | Default
---- | ---- | ----------- | -------
`lag` | <code>[int](#int)</code> | Number of periods to offset by before applying the transformation | *required*
`alpha` | <code>[float](#float)</code> | Smoothing factor | *required*

#### `ExponentiallyWeightedMean.stack`

```python
stack(transforms)
```

#### `ExponentiallyWeightedMean.take`

```python
take(idxs)
```

#### `ExponentiallyWeightedMean.transform`

```python
transform(ga)
```

#### `ExponentiallyWeightedMean.update`

```python
update(ga)
```
