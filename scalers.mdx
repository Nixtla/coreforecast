



# <kbd>module</kbd> `coreforecast.scalers`





---



## <kbd>function</kbd> `boxcox_lambda`

```python
boxcox_lambda(
    x: ndarray,
    season_length: int,
    lower: float = -0.9,
    upper: float = 2.0,
    method: str = 'guerrero'
) → float
```

Find optimum lambda for the Box-Cox transformation (supports negative numbers) 



**Args:**
 
 - <b>`x`</b> (np.ndarray):  Array with data to transform. 
 - <b>`season_length`</b> (int):  Length of the seasonal period. 
 - <b>`lower`</b> (float):  Lower bound for the lambda. 
 - <b>`upper`</b> (float):  Upper bound for the lambda. 
 - <b>`method`</b> (str):  Method to use. Valid options are 'guerrero'. 



**Returns:**
 
 - <b>`float`</b>:  Optimum lambda. 


---



## <kbd>function</kbd> `boxcox`

```python
boxcox(x: ndarray, lmbda: float) → ndarray
```

Apply the Box-Cox transformation 



**Args:**
 
 - <b>`x`</b> (np.ndarray):  Array with data to transform. 
 - <b>`lmbda`</b> (float):  Lambda value to use. 



**Returns:**
 
 - <b>`np.ndarray`</b>:  Array with the transformed data. 


---



## <kbd>function</kbd> `inv_boxcox`

```python
inv_boxcox(x: ndarray, lmbda: float) → ndarray
```

Invert the Box-Cox transformation 



**Args:**
 
 - <b>`x`</b> (np.ndarray):  Array with data to transform. 
 - <b>`lmbda`</b> (float):  Lambda value to use. 



**Returns:**
 
 - <b>`np.ndarray`</b>:  Array with the inverted transformation. 


---



## <kbd>class</kbd> `LocalMinMaxScaler`
Scale each group to the [0, 1] interval 




---



### <kbd>method</kbd> `fit`

```python
fit(ga: GroupedArray) → _BaseLocalScaler
```

Compute the statistics for each group. 



**Args:**
 
 - <b>`ga`</b> (GroupedArray):  Array with grouped data. 



**Returns:**
 
 - <b>`self`</b>:  The fitted scaler object. 

---



### <kbd>method</kbd> `fit_transform`

```python
fit_transform(ga: GroupedArray) → ndarray
```

"Compute the statistics for each group and apply the transformation. 



**Args:**
 
 - <b>`ga`</b> (GroupedArray):  Array with grouped data. 



**Returns:**
 
 - <b>`np.ndarray`</b>:  Array with the transformed data. 

---



### <kbd>method</kbd> `inverse_transform`

```python
inverse_transform(ga: GroupedArray) → ndarray
```

Use the computed statistics to invert the transformation. 



**Args:**
 
 - <b>`ga`</b> (GroupedArray):  Array with grouped data. 



**Returns:**
 
 - <b>`np.ndarray`</b>:  Array with the inverted transformation. 

---



### <kbd>method</kbd> `transform`

```python
transform(ga: GroupedArray) → ndarray
```

Use the computed statistics to apply the transformation. 



**Args:**
 
 - <b>`ga`</b> (GroupedArray):  Array with grouped data. 



**Returns:**
 
 - <b>`np.ndarray`</b>:  Array with the transformed data. 


---



## <kbd>class</kbd> `LocalStandardScaler`
Scale each group to have zero mean and unit variance 




---



### <kbd>method</kbd> `fit`

```python
fit(ga: GroupedArray) → _BaseLocalScaler
```

Compute the statistics for each group. 



**Args:**
 
 - <b>`ga`</b> (GroupedArray):  Array with grouped data. 



**Returns:**
 
 - <b>`self`</b>:  The fitted scaler object. 

---



### <kbd>method</kbd> `fit_transform`

```python
fit_transform(ga: GroupedArray) → ndarray
```

"Compute the statistics for each group and apply the transformation. 



**Args:**
 
 - <b>`ga`</b> (GroupedArray):  Array with grouped data. 



**Returns:**
 
 - <b>`np.ndarray`</b>:  Array with the transformed data. 

---



### <kbd>method</kbd> `inverse_transform`

```python
inverse_transform(ga: GroupedArray) → ndarray
```

Use the computed statistics to invert the transformation. 



**Args:**
 
 - <b>`ga`</b> (GroupedArray):  Array with grouped data. 



**Returns:**
 
 - <b>`np.ndarray`</b>:  Array with the inverted transformation. 

---



### <kbd>method</kbd> `transform`

```python
transform(ga: GroupedArray) → ndarray
```

Use the computed statistics to apply the transformation. 



**Args:**
 
 - <b>`ga`</b> (GroupedArray):  Array with grouped data. 



**Returns:**
 
 - <b>`np.ndarray`</b>:  Array with the transformed data. 


---



## <kbd>class</kbd> `LocalRobustScaler`
Scale each group using robust statistics 



**Args:**
 
 - <b>`scale`</b> (str):  Type of robust scaling to use. Valid options are 'iqr' and 'mad'.  If 'iqr' will use the inter quartile range as the scale.  If 'mad' will use median absolute deviation as the scale. 



### <kbd>method</kbd> `__init__`

```python
__init__(scale: str)
```








---



### <kbd>method</kbd> `fit`

```python
fit(ga: GroupedArray) → _BaseLocalScaler
```

Compute the statistics for each group. 



**Args:**
 
 - <b>`ga`</b> (GroupedArray):  Array with grouped data. 



**Returns:**
 
 - <b>`self`</b>:  The fitted scaler object. 

---



### <kbd>method</kbd> `fit_transform`

```python
fit_transform(ga: GroupedArray) → ndarray
```

"Compute the statistics for each group and apply the transformation. 



**Args:**
 
 - <b>`ga`</b> (GroupedArray):  Array with grouped data. 



**Returns:**
 
 - <b>`np.ndarray`</b>:  Array with the transformed data. 

---



### <kbd>method</kbd> `inverse_transform`

```python
inverse_transform(ga: GroupedArray) → ndarray
```

Use the computed statistics to invert the transformation. 



**Args:**
 
 - <b>`ga`</b> (GroupedArray):  Array with grouped data. 



**Returns:**
 
 - <b>`np.ndarray`</b>:  Array with the inverted transformation. 

---



### <kbd>method</kbd> `transform`

```python
transform(ga: GroupedArray) → ndarray
```

Use the computed statistics to apply the transformation. 



**Args:**
 
 - <b>`ga`</b> (GroupedArray):  Array with grouped data. 



**Returns:**
 
 - <b>`np.ndarray`</b>:  Array with the transformed data. 


---



## <kbd>class</kbd> `LocalBoxCoxScaler`
Find the optimum lambda for the Box-Cox transformation by group and apply it 



**Args:**
 
 - <b>`season_length`</b> (int):  Length of the seasonal period. 
 - <b>`lower`</b> (float):  Lower bound for the lambda. 
 - <b>`upper`</b> (float):  Upper bound for the lambda. 
 - <b>`method`</b> (str):  Method to use. Valid options are 'guerrero'. 



### <kbd>method</kbd> `__init__`

```python
__init__(
    season_length: int,
    lower: float = -0.9,
    upper: float = 2.0,
    method='guerrero'
)
```








---



### <kbd>method</kbd> `fit`

```python
fit(ga: GroupedArray) → _BaseLocalScaler
```

Compute the statistics for each group. 



**Args:**
 
 - <b>`ga`</b> (GroupedArray):  Array with grouped data. 



**Returns:**
 
 - <b>`self`</b>:  The fitted scaler object. 

---



### <kbd>method</kbd> `fit_transform`

```python
fit_transform(ga: GroupedArray) → ndarray
```

"Compute the statistics for each group and apply the transformation. 



**Args:**
 
 - <b>`ga`</b> (GroupedArray):  Array with grouped data. 



**Returns:**
 
 - <b>`np.ndarray`</b>:  Array with the transformed data. 

---



### <kbd>method</kbd> `inverse_transform`

```python
inverse_transform(ga: GroupedArray) → ndarray
```

Use the computed lambdas to invert the transformation. 



**Args:**
 
 - <b>`ga`</b> (GroupedArray):  Array with grouped data. 



**Returns:**
 
 - <b>`np.ndarray`</b>:  Array with the inverted transformation. 

---



### <kbd>method</kbd> `transform`

```python
transform(ga: GroupedArray) → ndarray
```

Use the computed lambdas to apply the transformation. 



**Args:**
 
 - <b>`ga`</b> (GroupedArray):  Array with grouped data. 



**Returns:**
 
 - <b>`np.ndarray`</b>:  Array with the transformed data. 


---



## <kbd>class</kbd> `AutoDifferences`
Find and apply the optimal number of differences to each group. 



**Args:**
 
 - <b>`max_diffs`</b> (int):  Maximum number of differences to apply. 



### <kbd>method</kbd> `__init__`

```python
__init__(max_diffs: int)
```








---



### <kbd>method</kbd> `fit_transform`

```python
fit_transform(ga: GroupedArray) → ndarray
```

Compute and apply the optimal number of differences for each group 



**Args:**
 
 - <b>`ga`</b> (GroupedArray):  Array with grouped data. 



**Returns:**
 
 - <b>`np.ndarray`</b>:  Array with the transformed data. 

---



### <kbd>method</kbd> `inverse_transform`

```python
inverse_transform(ga: GroupedArray) → ndarray
```

Invert the differences 



**Args:**
 
 - <b>`ga`</b> (GroupedArray):  Array with grouped data. 



**Returns:**
 
 - <b>`np.ndarray`</b>:  Array with the inverted transformation. 

---



### <kbd>method</kbd> `update`

```python
update(ga: GroupedArray) → ndarray
```

Update the last observations from each serie 



**Args:**
 
 - <b>`ga`</b> (GroupedArray):  Array with grouped data. 



**Returns:**
 
 - <b>`np.ndarray`</b>:  Array with the updated data. 


---



## <kbd>class</kbd> `AutoSeasonalDifferences`
Find and apply the optimal number of seasonal differences to each group. 



**Args:**
 
 - <b>`season_length`</b> (int):  Length of the seasonal period. 
 - <b>`max_diffs`</b> (int):  Maximum number of differences to apply. 
 - <b>`n_seasons`</b> (int | None):  Number of seasons to use to determine the number of differences. Defaults to 10.  If `None` will use all samples, otherwise `season_length` * `n_seasons` samples will be used for the test.  Smaller values will be faster but could be less accurate. 



### <kbd>method</kbd> `__init__`

```python
__init__(season_length: int, max_diffs: int, n_seasons: Optional[int] = 10)
```








---



### <kbd>method</kbd> `fit_transform`

```python
fit_transform(ga: GroupedArray) → ndarray
```

Compute and apply the optimal number of seasonal differences for each group 



**Args:**
 
 - <b>`ga`</b> (GroupedArray):  Array with grouped data. 



**Returns:**
 
 - <b>`np.ndarray`</b>:  Array with the transformed data. 

---



### <kbd>method</kbd> `inverse_transform`

```python
inverse_transform(ga: GroupedArray) → ndarray
```

Invert the seasonal differences 



**Args:**
 
 - <b>`ga`</b> (GroupedArray):  Array with grouped data. 



**Returns:**
 
 - <b>`np.ndarray`</b>:  Array with the inverted transformation. 

---



### <kbd>method</kbd> `update`

```python
update(ga: GroupedArray) → ndarray
```

Update the last observations from each serie 



**Args:**
 
 - <b>`ga`</b> (GroupedArray):  Array with grouped data. 



**Returns:**
 
 - <b>`np.ndarray`</b>:  Array with the updated data. 


---



## <kbd>class</kbd> `AutoSeasonalityAndDifferences`
Find the length of the seasonal period and apply the optimal number of differences to each group. 



**Args:**
 
 - <b>`max_season_length`</b> (int):  Maximum length of the seasonal period. 
 - <b>`max_diffs`</b> (int):  Maximum number of differences to apply. 
 - <b>`n_seasons`</b> (int | None):  Number of seasons to use to determine the number of differences. Defaults to 10.  If `None` will use all samples, otherwise `max_season_length` * `n_seasons` samples will be used for the test.  Smaller values will be faster but could be less accurate. 



### <kbd>method</kbd> `__init__`

```python
__init__(max_season_length: int, max_diffs: int, n_seasons: Optional[int] = 10)
```








---



### <kbd>method</kbd> `fit_transform`

```python
fit_transform(ga: GroupedArray) → ndarray
```

Compute the optimal length of the seasonal period and apply the optimal number of differences for each group 



**Args:**
 
 - <b>`ga`</b> (GroupedArray):  Array with grouped data. 



**Returns:**
 
 - <b>`np.ndarray`</b>:  Array with the transformed data. 

---



### <kbd>method</kbd> `inverse_transform`

```python
inverse_transform(ga: GroupedArray) → ndarray
```

Invert the seasonal differences 



**Args:**
 
 - <b>`ga`</b> (GroupedArray):  Array with grouped data. 



**Returns:**
 
 - <b>`np.ndarray`</b>:  Array with the inverted transformation. 

---



### <kbd>method</kbd> `update`

```python
update(ga: GroupedArray) → ndarray
```








---

_This file was automatically generated via [lazydocs](https://github.com/ml-tooling/lazydocs)._
